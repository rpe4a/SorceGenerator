using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SourceGenerator;

[Generator]
public class DemoSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var enumTypes = context
            .SyntaxProvider
            .CreateSyntaxProvider(CouldBeEnumerationAsync, GetEnumTypeOrNull)
            .Where(type => type is not null)
            .Collect();

        context.RegisterSourceOutput(enumTypes, GenerateCode);
    }

    private void GenerateCode(SourceProductionContext context, ImmutableArray<ITypeSymbol> enumTypes)
    {
        if (enumTypes.IsDefaultOrEmpty)
            return;

        foreach (var type in enumTypes)
        {
            var code = GenerateCode(type);
            var typeNamespace = type.ContainingNamespace.IsGlobalNamespace
                ? null
                : $"{type.ContainingNamespace}.";

            context.AddSource($"{typeNamespace}{type.Name}.g.cs", code);
        }
    }

    private static string GenerateCode(ITypeSymbol type)
    {
        var ns = type.ContainingNamespace.IsGlobalNamespace
            ? null
            : type.ContainingNamespace.ToString();
        var name = type.Name;
        var items = GetItemNames(type);

        return @$"// <auto-generated />

                using System;
                using System.Collections.Generic;

                {(ns is null ? null : $@"namespace {ns}
                {{")}
                   partial class {name}
                   {{
                      private static IReadOnlyList<{name}> _items;
                      public static IReadOnlyList<{name}> Items => _items ??= GetItems();

                      private static IReadOnlyList<{name}> GetItems()
                      {{
                         return {(items.Length == 0 ? $"Array.Empty<{name}>()" : $"new [] {{{string.Join(", ", items)}}}")};
                      }}
                   }}
                {(ns is null ? null : @"}
                ")}";
    }

    private static string?[] GetItemNames(ITypeSymbol type)
    {
        return type.GetMembers()
            .Select(m =>
            {
                if (!m.IsStatic ||
                    m.DeclaredAccessibility != Accessibility.Public ||
                    m is not IFieldSymbol field)
                    return null;

                return SymbolEqualityComparer.Default.Equals(field.Type, type)
                    ? field.Name
                    : null;
            })
            .Where(field => field is not null)
            .ToArray();
    }

    private ITypeSymbol? GetEnumTypeOrNull(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        var attributeSyntax = (AttributeSyntax)context.Node;

        // "attribute.Parent" is "AttributeListSyntax"
        // "attribute.Parent.Parent" is a C# fragment the attributes are applied to
        if (attributeSyntax.Parent?.Parent is not ClassDeclarationSyntax classDeclaration)
            return null;

        var type = ModelExtensions.GetDeclaredSymbol(context.SemanticModel, classDeclaration) as ITypeSymbol;

        return type is null || !IsEnumeration(type) ? null : type;
    }

    public static bool IsEnumeration(ISymbol type)
    {
        return type.GetAttributes()
            .Any(a => a.AttributeClass?.Name == "EnumGenerationAttribute" &&
                      a.AttributeClass.ContainingNamespace is
                      {
                          Name: "SourceGeneratorLibrary",
                          ContainingNamespace.IsGlobalNamespace: true
                      });
    }

    private bool CouldBeEnumerationAsync(SyntaxNode syntaxNode, CancellationToken cancellationToken)
    {
        if (syntaxNode is not AttributeSyntax attribute)
            return false;

        var name = ExtractName(attribute.Name);

        if (name is not ("EnumGeneration" or "EnumGenerationAttribute"))
            return false;

        // "attribute.Parent" is "AttributeListSyntax"
        // "attribute.Parent.Parent" is a C# fragment the attributes are applied to
        return attribute.Parent?.Parent is ClassDeclarationSyntax classDeclaration && IsPartial(classDeclaration);
    }

    public static bool IsPartial(ClassDeclarationSyntax classDeclaration)
    {
        return classDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
    }

    private string? ExtractName(NameSyntax? name)
    {
        while (name != null)
        {
            switch (name)
            {
                case IdentifierNameSyntax ins:
                    return ins.Identifier.Text;

                case QualifiedNameSyntax qns:
                    name = qns.Right;
                    break;

                default:
                    return null;
            }
        }

        return null;
    }
}